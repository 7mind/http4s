{"name":"Http4s","tagline":"A minimal, idiomatic interface for Scala HTTP services","body":"# Http4s\r\n\r\nHttp4s is a minimal, idiomatic Scala interface for Scala HTTP services.  Http4s is Scala's answer to Ruby's Rack, Python's WSGI, Haskell's WAI, and Java's Servlets.\r\n\r\n## HttpService ##\r\n\r\nAn `HttpService` is just a `PartialFunction[Request, Task[Response]]`.  Http4s provides a variety\r\nof helpers to facilitate the creation of the `Task[Response]` from common results.\r\n\r\n```scala\r\n// A simple route definition using the optional Http4s DSL\r\nval service: HttpService = {\r\n  //  We use the micro DSL to match the path of the Request to the familiar uri form\r\n  case Get -> Root / \"hello\" =>\r\n    // We could make a Task[Response] manually, but we use the\r\n    // EntityResponseGenerator 'Ok' for convenience\r\n    Ok(\"Hello, better world.\")\r\n}\r\n```\r\n\r\nHttpServices are _type safe_, _composable_, and _asynchronous_.\r\n\r\n### Type safety\r\n\r\n`Request` and `Response` sit at the top level of a typed, immutable model of HTTP. \r\n\r\n* Well-known headers are lazily parsed into a rich model derived from Spray HTTP.\r\n* Bodies are parsed and generated from a [scalaz-stream](http://github.com/scalaz/scalaz-stream) of bytes.\r\n\r\n### Composable\r\n\r\nNot only does making an `HttpService` a `PartialFunction` make it simple to define a service,\r\nit also makes it easy to compose them.  Adding gzip compression or rewriting URIs is\r\nas simple as applying a middleware to an `HttpService`.\r\n\r\n```scala\r\nval wcompression = middleware.GZip(service)\r\nval translated   = middleware.URITranslation.translateRoot(\"/http4s\")(service)\r\n```\r\n\r\n### Asynchronous\r\n\r\nAny Http4s response can be streamed from an asynchronous source. Http4s offers a variety\r\nof helpers to help you get your data out the door in the fastest way possible.\r\n\r\n```scala\r\n// Make your model safe and streaming by using a scalaz-stream Process\r\ndef getData(req: Request): Process[Task, String] = ???\r\n\r\nval service: HttpService = {\r\n  // Wire your data into your service\r\n  case Get -> Root / \"streaming\" => Ok(getData(req))\r\n\r\n  // You can use helpers to send any type of data with an available Writable[T]\r\n  case Get -> Root / \"synchronous\" => Ok(\"This is good to go right now.\")\r\n}\r\n```\r\n\r\nHttp4s is a forward-looking technology.  HTTP/2.0 and WebSockets will play a central role.\r\n\r\n```scala\r\nval route: HttpService = {\r\n  case req@ Get -> Root / \"ws\" =>\r\n    // Send a Text message with payload 'Ping! delay' every second\r\n    val src = Process.awakeEvery(1.seconds).map{ d => Text(s\"Ping! $d\") }\r\n\r\n    // Print received Text frames, and, on completion, notify the console\r\n    val sink: Sink[Task, WSFrame] = Process.constant {\r\n      case Text(t) => Task.delay( println(t))\r\n      case f       => Task.delay(println(s\"Unknown type: $f\"))\r\n    }.onComplete(Process.eval(Task{ println(\"Terminated!\")}).drain)\r\n\r\n    // Use the WS helper to make the Task[Response] carrying the info\r\n    // needed for the backend to upgrade to a WebSocket connection\r\n    WS(src, sink)\r\n\r\n  case req @ Get -> Root / \"wsecho\" =>\r\n    // a scalaz topic acts as a hub to publish and subscribe to messages safely\r\n    val t = topic[WSFrame]\r\n    val src = t.subscribe.collect{ case Text(msg) => Text(\"You sent the server: \" + msg) }\r\n    WS(src, t.publish)\r\n}\r\n```\r\n\r\n## Choose your backend\r\n\r\nHttp4s supports running the same service on multiple backends.  Pick the deployment model that fits your needs now, and easily port if and when your needs change.\r\n\r\n### Blaze\r\n\r\n[Blaze](http://github.com/http4s/blaze) is an NIO framework.  Run Http4s on Blaze for maximum throughput.\r\n\r\n```scala\r\nobject BlazeWebSocketExample extends App {\r\n  // Provides a template for the blaze pipeline\r\n  def pipebuilder(): LeafBuilder[ByteBuffer] =\r\n    new Http1Stage(URITranslation.translateRoot(\"/http4s\")(route)) with WebSocketSupport\r\n\r\n  // Bind the socket and begin serving\r\n  new SocketServerChannelFactory(pipebuilder, 12, 8*1024)\r\n    .bind(new InetSocketAddress(8080))\r\n    .run()\r\n}\r\n```\r\n\r\n### Servlets\r\n\r\nHttp4s is committed to first-class support of the Servlet API.  Develop and deploy services on your existing infrastructure, and take full advantage of the mature JVM ecosystem.\r\n\r\n```scala\r\nobject ServletExample extends App {\r\n  val server = new Server(8080)\r\n  val context = new ServletContextHandler()\r\n  context.setContextPath(\"/\")\r\n  server.setHandler(context)\r\n  context.addServlet(new ServletHolder(service), \"/http4s/*\")\r\n  server.start()\r\n  server.join()\r\n}\r\n```\r\n\r\n## Build & run ##\r\n\r\n```sh\r\n$ https://github.com/http4s/http4s.git\r\n$ cd http4s\r\n$ sbt examples/run\r\n```\r\n\r\n## Project info ##\r\n\r\n* [GitHub](http://github.com/http4s/http4s)\r\n* [Travis CI ![BuildStatus](https://travis-ci.org/http4s/http4s.svg?branch=develop)](https://travis-ci.org/http4s/http4s)\r\n* [Scaladoc](http://http4s.org/api/0.1)\r\n* IRC: #http4s on Freenode.\r\n* [Twitter](http://twitter.com/http4s)\r\n\r\n## Hat tips\r\n\r\n* HTTP model forked from [spray-http](http://spray.io/documentation/1.2.1/spray-http/), which derives from [Blueeyes](https://github.com/jdegoes/blueeyes).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}